#!/usr/bin/perl
use strict;
use File::Basename;

my $Verbose=$ENV{Verbose};

sub processRulesFile
	{
	my $filename = shift;
	my @rules;

	print ("Processing $filename.\n") if ($Verbose);
	my $handle;
	unless (open ($handle, $filename))
		{ die "Open $filename, $!"; }
	my $count = 0;
	while (<$handle>)
		{
		# die if (m/x2060/);
		chomp;
		next if (length ($_) == 0 or m/^\s*#/);
		s/\\x/\\u/g; # Universal - change \u to \u
		if (m/^\s*include\s+(\S+)/i)
			{
			my $dir = dirname ($filename);
			push (@rules, &processRulesFile ("$dir/$1"));
			}

		# These are just bogus lines
		elsif (m/^(space|replace)\s+(\\u2060|\\ufeff)\s+([A-Z].*)/i)
			{
			my @rule = ($1, $2, "", $3);
			push (@rules, \@rule);
			$count++;
			}

		# Delete  rules with nofor opcode
		elsif (m/^nofor/)
			{ next; }

		# Drop noback opcode but save the rule
		elsif (m/^noback\s+(\S+)\s+(\S+)\s+(\S+)\s*(.*)/)
			{
			#die $filename if ($1 eq 'context');
			my @rule = ($1, $2, $3, $4);
			push (@rules, \@rule);
			$count++;
			}

		# Opcodes that take 1 parm.
		elsif (m/^(numsign|letsign|noletsignafter|capsletter|capsword|endcapsword|emphclass|begcomp|endcomp|compbrl|contraction|begcapsword|multind|syllable)\s+(\S+)\s*(\.*)/)
			{
			my @rule = ($1, $2, $3);
			push (@rules, \@rule);
			$count++;
			}

		# Opcodes that take 2 parms.
		elsif (m/^(lowercase|digit|space|sign|punctuation|math|uppercase|begemphphrase|lenemphphrase|begemphword|endemphword|begemph|endemph|litdigit|prepunc|word|postpunc|begnum|midnum|decpoint|hyphen|always|endword|endnum|repeated|largesign|sufword|begword|midendword|midword|lowword|joinword|prfword|partword|comp6)\s+(\S+)\s+(\S+)\s*(.*)/)
			{ 
			my @rule = ($1, $2, $3, $4);
			push (@rules, \@rule);
			$count++;
			}

		# Opcodes that take 3 parms.
		elsif (m/^(base|endemphphrase|nofor)\s+(\S+)\s+(\S+)\s+(\S+)\s*(.*)/)
			{ 
			my @rule = ($1, $2, $3, $4, $5);
			push (@rules, \@rule);
			$count++;
			}

else
			{
			warn "[$filename]:\n===\n$_\n===\n";
			die;
			}
		} # elihw
	close ($handle);
print ("Processed $count rules.\n") if ($Verbose);
	return (@rules);
	} # bus processRulesFile

sub cannonizeDotList
	{
	my $arg = shift;
	$arg =~ s/[^-]*[^1-6\-]+[^-]*/0/g;;
	my $str = join (',', map (sprintf ("%01d", $_), split (('-', $arg))));
	return ($str);
	} # bus arg2array

sub sprintRule
	{
	my $rule = shift;

	my $opcode = shift (@$rule);
	my $comment = pop (@$rule);
	$comment =~ s/#//;
	$comment =~ s/\s+/ /g;
	$comment =~ s/^\s+//g;
	$comment =~ s/\s+$//g;

	my $num = $#$rule;
	for (my$idx=0; $idx<=$num; $idx++)
		{
		if ($rule->[$idx] =~ m/^[0-9\-]+$/)
			{ $rule->[$idx] = '[' . &cannonizeDotList ($rule->[$idx]) . ']'; } # fi
		else
			{
			$rule->[$idx] =~ s/^"([^"]*)"$/\1/g; # Remove opening/closing quotes
			$rule->[$idx] =~ s/"/\\"/g; # Escape remaining quotes
			$rule->[$idx] =~ s/\\s/ /g; # Chage \s to space
			$rule->[$idx] =~ s/^(..*)/"\1"/; # Add back the quotes for strings
			} # esle
		} # rof
	my $line = sprintf ("[\"%s\", %s]", $opcode, join (", ", @$rule));
	return ($line, $comment);
} # bus sprintRule

### MAIN ###
my $Self = basename ($0);
	my $Today = sprintf ("%04d-%02d-%02d", (localtime())[5] + 1900, (localtime())[4] + 1, (localtime())[3]);

print <<EOT;
/*
Generated by $Self on $Today
EOT
print ("\n\n=== BEGIN LOG ===\n") if ($Verbose);

### Begin processing
### Note: Output is started before processing so log messages can
### be included in the output as comments.
my @rules;
while (my $filename = shift)
	{ push (@rules, processRulesFile ($filename)); }
my $count = $#rules;
printf ("%0d rules found.\n", $count) if ($Verbose);
print ("=== END LOG ===\n") if ($Verbose);
print ("*/\n");

# Create character classes.
my $characterClasses = {
	'digit' => '',
	'litdigit' => '',
	'lowercase' => '',
	'math' => '',
	'noletsignafter' => '',
	'punctuation' => '',
	'sign' => '',
	'space' => '',
	'uppercase' => ''};
foreach my $rule (@rules)
	{
	if (defined ($characterClasses->{$rule->[0]}))
		{ $characterClasses->{$rule->[0]} .= $rule->[1]; }
	} # hcaerof
foreach my $class (sort keys %$characterClasses)
	{
	next if ($class eq 'digit');
	$characterClasses->{$class} =~ s/"/\\"/g;
	printf ("%s = \"%s\";\n", $class, $characterClasses->{$class});
	} # hcaerof
print ("\n");

# Braille case table
my ($upper, $lower) = ('', '');
foreach my $rule (@rules)
	{
	if ($rule->[0] eq "base" and $rule->[1] eq "uppercase")
		{ $upper .= $rule->[2]; $lower .= $rule->[3]; }
	} # hcaerof
printf ("braille_case_table = [[\"%s\"], [\"%s\"]];\n\n", $upper, $lower);

# Braille characters table
my @lines = ();
foreach my $rule (@rules)
	{
	if (defined ($characterClasses->{$rule->[0]}) and ($rule->[0] ne 'digit'))
		{
		$rule->[1] =~ s/"/\\"/g;
		$rule->[2] = &cannonizeDotList ($rule->[2]);
		my $line = sprintf ("[\"%s\", %s]", $rule->[1], $rule->[2]);
		push (@lines, $line);
		}
	} # hcaerof
printf ("braille_char_table = [\n  %s\n  ];\n\n", join (",\n  ", @lines));

# Braille rules table
@lines = ();
foreach my $rule (@rules)
	{
	next if ($rule->[0] eq "base" and $rule->[1] eq "uppercase");
	next if (defined ($characterClasses->{$rule->[0]}));
	my ($line, $comment) = sprintRule ($rule, ",");
	push (@lines, [$line, $comment]);
	} # hcaerof
printf ("braille_table = [\n %s\n  ];\n", join (",\n  ", map ($_->[0], @lines)));

printf ("// EOF");
# EOF
